# 1. 红黑树(RBT  Red–black tree)
红黑树是一种自平衡的二叉查找树

## 1.1 二叉查找树(BST  Binary Search Tree)

1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
4. 没有键值相等的节点（no duplicate nodes）。

在理想的情况下，二叉查找树增删查改的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。

![image](https://user-images.githubusercontent.com/62703976/157433909-5bf6c37b-4501-4776-b3ff-f1f6b00790b1.png)

二叉查找树的问题：查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。极端插入情况下二叉查找树会退化成线性表。
为了实现更高效的查询效率，产生了平衡树(Self-balancing binary search tree)，平衡指所有叶子的深度趋于平衡。

BST的查找操作
```

T  key = a search key
Node root = point to the root of a BST

while(true){
    if(root==null){
        break;
    }
    if(root.value.equals(key)){
        return root;
    }
    else if(key.compareTo(root.value)<0){
        root = root.left;
    }
    else{
        root = root.right;
    }
}
return null;

```
从程序中可以看出，当BST查找的时候，先与当前节点进行比较：

如果相等的话就返回当前节点；

如果少于当前节点则继续查找当前节点的左节点；

如果大于当前节点则继续查找当前节点的右节点。

直到当前节点指针为空或者查找到对应的节点，程序查找结束。

BST的插入操作
```

Node node = create a new node with specify value
Node root = point the root node of a BST
Node parent = null;

//find the parent node to append the new node
while(true){
   if(root==null)break;
   parent = root;
   if(node.value.compareTo(root.value)<=0){
      root = root.left;  
   }else{
      root = root.right;
   } 
}
if(parent!=null){
   if(node.value.compareTo(parent.value)<=0){//append to left
      parent.left = node;
   }else{//append to right
      parent.right = node;
   }
}

```
插入操作先通过循环查找到待插入的节点的父节点，和查找父节点的逻辑一样，都是比大小，小的往左，大的往右。

找到父节点后，对比父节点，小的就插入到父节点的左节点，大就插入到父节点的右节点上。


## 1.2 红黑树定义:

1. 每个节点非红即黑；
2. 根节点总是黑色的；
3. 每个叶子节点都是黑色的空节点（NIL节点）；
4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；
5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

特点总结：根黑、红子、黑高  

## 1.3 红黑树的旋转操作
旋转操作(Rotate)的目的是使节点颜色符合定义，让RBTree的高度达到平衡。

Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。

![image](https://user-images.githubusercontent.com/62703976/157435785-872ccf86-d78e-4c57-97bd-4ab125eaffc4.png)

## 1.4 红黑树的插入
RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（在这里简称插入修复），使得它符合RBTree的定义。

新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束(因为不会违背红黑树的定义)。也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。

插入修复操作分为以下的三种情况，而且新插入的节点的父节点都是红色的：

- 叔叔节点也为红色。

- 叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上。

- 叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上。

情况一 叔叔节点也为红色。

将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTRee的定义。即维持了高度的平衡，修复后颜色也符合RBTree定义的第三条和第四条。
下图中，操作完成后A节点变成了新的节点。如果A节点的父节点不是黑色的话，则继续做修复操作。

![image](https://user-images.githubusercontent.com/62703976/157436751-4ac2d6a8-d1f8-4f9a-8a1a-658f6f87b03e.png)

情况二 叔叔为空 且处于一条斜线上

将B节点进行右旋操作，并且和父节点A互换颜色。通过该修复操作RBTRee的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以了。

![image](https://user-images.githubusercontent.com/62703976/157436879-22a382bc-3253-4d43-bc0b-5a3ff73f1e21.png)

情况三 叔叔为空 且不处于一条斜线上

将C节点进行左旋，这样就从情况三 转换成情况二了，然后针对情况二进行操作处理就行了。情况二操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结构，则只需要将对应的左旋变成右旋，右旋变成左旋即可。

![image](https://user-images.githubusercontent.com/62703976/157437561-2f3ae96b-7bc5-4a1f-9b83-a6effe58f4b9.png)





