# 1. 红黑树(RBT  Red–black tree)
红黑树是一种自平衡的二叉查找树

## 1.1 二叉查找树(BST  Binary Search Tree)

1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
4. 没有键值相等的节点（no duplicate nodes）。

在理想的情况下，二叉查找树增删查改的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。

![image](https://user-images.githubusercontent.com/62703976/157433909-5bf6c37b-4501-4776-b3ff-f1f6b00790b1.png)

二叉查找树的问题：查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。极端插入情况下二叉查找树会退化成线性表。
为了实现更高效的查询效率，产生了平衡树(Self-balancing binary search tree)，平衡指所有叶子的深度趋于平衡。

BST的查找操作
```

T  key = a search key
Node root = point to the root of a BST

while(true){
    if(root==null){
        break;
    }
    if(root.value.equals(key)){
        return root;
    }
    else if(key.compareTo(root.value)<0){
        root = root.left;
    }
    else{
        root = root.right;
    }
}
return null;

```
从程序中可以看出，当BST查找的时候，先与当前节点进行比较：

如果相等的话就返回当前节点；

如果少于当前节点则继续查找当前节点的左节点；

如果大于当前节点则继续查找当前节点的右节点。

直到当前节点指针为空或者查找到对应的节点，程序查找结束。

BST的插入操作
```

Node node = create a new node with specify value
Node root = point the root node of a BST
Node parent = null;

//find the parent node to append the new node
while(true){
   if(root==null)break;
   parent = root;
   if(node.value.compareTo(root.value)<=0){
      root = root.left;  
   }else{
      root = root.right;
   } 
}
if(parent!=null){
   if(node.value.compareTo(parent.value)<=0){//append to left
      parent.left = node;
   }else{//append to right
      parent.right = node;
   }
}

```
插入操作先通过循环查找到待插入的节点的父节点，和查找父节点的逻辑一样，都是比大小，小的往左，大的往右。

找到父节点后，对比父节点，小的就插入到父节点的左节点，大就插入到父节点的右节点上。


## 1.2 红黑树定义:

1. 每个节点非红即黑；
2. 根节点总是黑色的；
3. 每个叶子节点都是黑色的空节点（NIL节点）；
4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；(或者父子节点不会右两个连续的红节点)
5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

特点总结：根黑、父子、黑高  

## 1.3 红黑树的旋转操作
旋转操作(Rotate)的目的是使节点颜色符合定义，让RBTree的高度达到平衡。

Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。

![image](https://user-images.githubusercontent.com/62703976/157435785-872ccf86-d78e-4c57-97bd-4ab125eaffc4.png)

## 1.4 红黑树的插入
RBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（在这里简称插入修复），使得它符合RBTree的定义。

新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束(因为不会违背红黑树的定义)。也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。

插入修复操作分为以下的三种情况，而且新插入的节点的父节点都是红色的：

- 叔叔节点也为红色。

- 叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上。

- 叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上。

情况一 叔叔节点也为红色。

将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTRee的定义。即维持了高度的平衡，修复后颜色也符合RBTree定义的第三条和第四条。
下图中，操作完成后A节点变成了新的节点。如果A节点的父节点不是黑色的话，则继续做修复操作。

![image](https://user-images.githubusercontent.com/62703976/157436751-4ac2d6a8-d1f8-4f9a-8a1a-658f6f87b03e.png)

情况二 叔叔为空 且处于一条斜线上

将B节点进行右旋操作，并且和父节点A互换颜色。通过该修复操作RBTRee的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以了。

![image](https://user-images.githubusercontent.com/62703976/157436879-22a382bc-3253-4d43-bc0b-5a3ff73f1e21.png)

情况三 叔叔为空 且不处于一条斜线上

将C节点进行左旋，这样就从情况三 转换成情况二了，然后针对情况二进行操作处理就行了。情况二操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结构，则只需要将对应的左旋变成右旋，右旋变成左旋即可。

![image](https://user-images.githubusercontent.com/62703976/157437561-2f3ae96b-7bc5-4a1f-9b83-a6effe58f4b9.png)

_ _ 总结

* 插入后的修复操作是一个向root节点回溯的操作，一旦牵涉的节点都符合了红黑树的定义，修复操作结束。
* 
* 之所以会向上回溯是由于情况一操作会将父节点，叔叔节点和祖父节点进行换颜色，有可能会导致祖父节点不平衡(红黑树定义4,父子)。这个时候需要对祖父节点为起点进行调节（向上回溯）。

## 1.5 红黑树的删除

删除操作首先需要做的也是BST的删除操作，删除操作会删除对应的节点，
如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。

删除后就需要做删除修复操作，使的树符合红黑树的定义，符合定义的红黑树高度是平衡的。

删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的黑高。

需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。

> 删除黑色节点后的修复分成四种情况
> - 兄弟节点是红色的
> - 兄弟节点是黑色的，侄子节点都是黑色的
> - 右边兄弟节点是黑色的，兄弟的左孩子是红色的，右孩子是黑色的，如果左边兄弟则相反
> - 右边兄弟节点是黑色的，而且右孩子节点是红色的，若左边兄弟则相反

case 1

由于兄弟节点是红色节点的时候，无法借调黑节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。

case 1这样转换之后就会变成后面的case 2，case 3，或者case 4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。

之所以要做case 1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。

![image](https://user-images.githubusercontent.com/62703976/157439849-93b09176-d493-4294-bf99-5ef58e1013a8.png)

case 2

case 2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整颗树的颜色符合RBTree的定义为止。

case 2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。

![image](https://user-images.githubusercontent.com/62703976/157439911-10da9c43-00e0-4c8c-a5fa-d1158cb5a8aa.png)

case 3

case 3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case 4状态了，在case 4状态下可以将D，E节点都阶段过来，通过将两个节点变成黑色来保证红黑树的整体平衡。

之所以说case-3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，他是通过case 2操作完后向上回溯出现的状态。之所以会出现case 3和后面的case 4的情况，是因为可以通过借用侄子节点的红色，变成黑色来符合红黑树定义4.

![image](https://user-images.githubusercontent.com/62703976/157439982-cf3e4be4-11ce-445a-bc4a-0ece7c3338f2.png)

case 4

Case 4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑节点的目的，这样的话，整棵树还是符合RBTree的定义的。

Case 4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑节点使用，从而保持整棵树都符合红黑树的定义。

![image](https://user-images.githubusercontent.com/62703976/157440030-c1d2f33f-ea27-415d-9761-94f5e48dc947.png)

__ __ 总结

红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。

对于兄弟节点是黑色节点的可以分成3种情况来处理，当所以的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。

对于兄弟节点的子节点为左红右黑或者 (全部为红，右红左黑)这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。

红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。

